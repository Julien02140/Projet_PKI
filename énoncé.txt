Projet à rendre pour le 30 Mai

Simulation d'une CA :
-On lui demande un certif et elle le renvoi.
-On lui demande de nous dire si un certificat est révoqué.
-Créer sa paire de clés, génère son certificat auto signé.
-Utilisation de X509; Sha256; 2048 octets.
-On lui insère des certificats révoqué pour alimenter sa CRL (Certificate Revocation List)

Scénario :

Vendeur : on lui vend un certif
Un client, qui se connecte au vendeur, le vendeur lui envoi son certificat
le client doit vérifier si le certificat est révoqué, si il est valide :
Etablir des scénarios sur 3 clients par ex :
1)Vérifier simplement le certificat
2) Même que 1, mais vérifie si le certificat est révoqué.
3) Même que 2, et il se rend compte que le vendeur est révoqué.

Il est conseillé d'avoir un vendeur (1 non révoquer, et 1 qui est révoqué)
Echange sécurisé, échange aux socket. <- peut être par fil MQTT.

fil mqtt : 194.57.103.203

port : 1883
topic : vehicule

Faire un rapport (maximum 10 pages)

Faire des commentaires, sinon 0

demander un certificat psuedonyme.

vu que c'est independant, avec le message on envoit le pseudonyme avec pour que les autres sites
savent que c'est bien le bon noeud qui a envoyé.

Le LTC est utilisé pour demander le certificat à la  pki, on ne l'utilise pas pour signer les messages.


on envoit message,certificat et signature

1) on verifie le psuedonyme et si le message est signé par la pki
2)

ON ENVOIT JAMAIS LA CLE PRIVEE, ELLE EST PRIVEE

fonctions à utiliser :

- Gen_key(x) qui produit une paire de clés : publique Pub(x) et privée Priv(x).
- Ext_Priv(x,y) qui extrait la clé privée y de la paire x
- Ext_Pub(x,y) qui extrait la clé publique y de la paire x
- Chif_asym(M,Kpub,M') qui  chiffre le message M avec la clé publique Kpub et produit le message chiffré M'
- Dechif_asym(M,Kpriv,M') qui  déchiffre le message M avec la clé privée Kpriv et produit le message déchiffré M'
- Signe(M,Kpriv,s) qui signe le message M avec la clé privée Kpriv et produit la signature s
- Verifie(M,Kpub,s) qui vérifie que la signature s a bien été produite par la signature du message M avec la clé privée associée à la clé publique Kpub.
- Chif_sym(M,K,M') qui  chiffre en symétrique le message M avec la clé K et produit le message chiffré M'
- Dechif_sym(M,K,M') qui  déchiffre le message M avec la clé K et produit le message déchiffré M'
- Envoi(S,M,D) qui envoie un message  M de la source S à la destination D, si D="*", le message est envoyé à tous les voisins situés dans le rayon de transmission.
- Reçois(S,M,D) qui  reçoit un message  M de la source  S à la destination D
- Créer_Certif(Pub, s, date, C) qui crée un certificat C avec la clé publique Pub et sa signature s de la part de la PKI avec une date de validité d'une année date.
- hasher(M,e) qui hache M en une empreinte e.

Ecrire algo : A envoit à B, et B authentifie le message :

A demande le cetrificat à la pki :

explication : 

A genere ses clés
il envoit un message avec sa clé publique à la pki, il signe le message avec sa clé privée (la clée privée est lié au LTC)
la pki reçoit le message, et creer un certificat avec la clé publique de A, un pseudonyme, et la signature de la pki (elle signe la clé publique)
la pki envoit le certificat

algo A:

Gen_key(x)
Ext_Pub(x,Pseudo_pub_A)
S <- Random()
chiffre_asym(S,CERTpki,S')
Envoi(A,S',PKI)
Chif_asym(Pseudo_pub_A,S,PPA)
Envoi(A,PPA,PKI)
Recçoit(PKI,CERT_Pseudo_A,A)

algo PKI :



A envoit un message à B :

Explication:
A envoit son message, la signature et la certif
B verifie le message grâce à la signature, on verifie que la singature correspond à ce qu'il y dans le certificat et on verifie que le
certificat est légitime en vérifiant la signature de la pki en la comparant avec la certifPKI (tout les sites ont la certif pki)

Algo A:
signe(M,Kpriv_A,M')
envoie(Moi,CERT_Pseudo_A + M' + M,B)

Algo B:
recoit(B,M,Moi)
deconcatenation(M,CERT_Pseudo_A,signature_A,message_A)
if Verifie(CERT_Pseudo_A.pub.k,CERTPKI.pub.k,CERT_Pseudo_A.signature)
    Verifie(message_A,CERT_Pseudo_A.pub.k,signature_A)



message = "embouteillage"
Signe(message,priv_key,signature)
envoi


Gen_key(x)
priv = ext_priv(x,y)
pub = ext_pub(x,y)
message = ("demande de certif",priv)
chif_asym(message,pub,message')



