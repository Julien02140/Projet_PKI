Projet à rendre pour le 30 Mai

Simulation d'une CA :
-On lui demande un certif et elle le renvoi.
-On lui demande de nous dire si un certificat est révoqué.
-Créer sa paire de clés, génère son certificat auto signé.
-Utilisation de X509; Sha256; 2048 octets.
-On lui insère des certificats révoqué pour alimenter sa CRL (Certificate Revocation List)

Scénario :

Vendeur : on lui vend un certif
Un client, qui se connecte au vendeur, le vendeur lui envoi son certificat
le client doit vérifier si le certificat est révoqué, si il est valide :
Etablir des scénarios sur 3 clients par ex :

1. Vérifier simplement le certificat
2. Même que 1, mais vérifie si le certificat est révoqué.
3. Même que 2, et il se rend compte que le vendeur est révoqué.

Il est conseillé d'avoir un vendeur (1 non révoquer, et 1 qui est révoqué)
Echange sécurisé, échange aux socket. <- peut être par fil MQTT.

fil mqtt : 194.57.103.203

port : 1883
topic : vehicule

Faire un rapport (maximum 10 pages)

Faire des commentaires, sinon 0

demander un certificat psuedonyme.

vu que c'est independant, avec le message on envoit le pseudonyme avec pour que les autres sites
savent que c'est bien le bon noeud qui a envoyé.

Le LTC est utilisé pour demander le certificat à la  pki, on ne l'utilise pas pour signer les messages.


on envoit message,certificat et signature

1) on verifie le psuedonyme et si le message est signé par la pki
2)

ON ENVOIT JAMAIS LA CLE PRIVEE, ELLE EST PRIVEE

fonctions à utiliser :

- Gen_key(x) qui produit une paire de clés : publique Pub(x) et privée Priv(x).
- Ext_Priv(x,y) qui extrait la clé privée y de la paire x
- Ext_Pub(x,y) qui extrait la clé publique y de la paire x
- Chif_asym(M,Kpub,M') qui  chiffre le message M avec la clé publique Kpub et produit le message chiffré M'
- Dechif_asym(M,Kpriv,M') qui  déchiffre le message M avec la clé privée Kpriv et produit le message déchiffré M'
- Signe(M,Kpriv,s) qui signe le message M avec la clé privée Kpriv et produit la signature s
- Verifie(M,Kpub,s) qui vérifie que la signature s a bien été produite par la signature du message M avec la clé privée associée à la clé publique Kpub.
- Chif_sym(M,K,M') qui  chiffre en symétrique le message M avec la clé K et produit le message chiffré M'
- Dechif_sym(M,K,M') qui  déchiffre le message M avec la clé K et produit le message déchiffré M'
- Envoi(S,M,D) qui envoie un message  M de la source S à la destination D, si D="*", le message est envoyé à tous les voisins situés dans le rayon de transmission.
- Reçois(S,M,D) qui  reçoit un message  M de la source  S à la destination D
- Créer_Certif(Pub, s, date, C) qui crée un certificat C avec la clé publique Pub et sa signature s de la part de la PKI avec une date de validité d'une année date.
- hasher(M,e) qui hache M en une empreinte e.

Ecrire algo : A envoit à B, et B authentifie le message :

A demande le cetrificat à la pki :

explication : 

A genere ses clés
il envoit un message avec sa clé publique à la pki, il signe le message avec sa clé privée (la clée privée est lié au LTC)
la pki reçoit le message, et creer un certificat avec la clé publique de A, un pseudonyme, et la signature de la pki (elle signe la clé publique)
la pki envoit le certificat

algo A:

Gen_key(x)
Ext_Pub(x,Pseudo_pub_A)
S <- Random()
chiffre_asym(S,CERTpki,S')
Envoi(A,S',PKI)
Chif_asym(Pseudo_pub_A,S,PPA)
Envoi(A,PPA,PKI)
Recçoit(PKI,CERT_Pseudo_A,A)

algo PKI :



A envoit un message à B :

Explication:
A envoit son message, la signature et la certif
B verifie le message grâce à la signature, on verifie que la singature correspond à ce qu'il y dans le certificat et on verifie que le
certificat est légitime en vérifiant la signature de la pki en la comparant avec la certifPKI (tout les sites ont la certif pki)

Algo A:
signe(M,Kpriv_A,M')
envoie(Moi,CERT_Pseudo_A + M' + M,B)

Algo B:
recoit(B,M,Moi)
deconcatenation(M,CERT_Pseudo_A,signature_A,message_A)
if Verifie(CERT_Pseudo_A.pub.k,CERTPKI.pub.k,CERT_Pseudo_A.signature)
    Verifie(message_A,CERT_Pseudo_A.pub.k,signature_A)



message = "embouteillage"
Signe(message,priv_key,signature)
envoi


Gen_key(x)
priv = ext_priv(x,y)
pub = ext_pub(x,y)
message = ("demande de certif",priv)
chif_asym(message,pub,message')

Demande de certificat par le vendeur : Le vendeur soumet une demande de certificat à la CA. Cette demande peut être initiée manuellement par le vendeur ou automatisée via un processus en ligne.
Validation de l'identité du vendeur par la CA : La CA vérifie l'identité du vendeur en demandant des informations d'identification et en effectuant des vérifications. Cela peut inclure la vérification des documents d'entreprise, des preuves de propriété de domaine, des vérifications téléphoniques, etc.
Génération de la paire de clés : Le vendeur génère une paire de clés cryptographiques, composée d'une clé privée et d'une clé publique. La clé privée est gardée secrète et utilisée pour signer numériquement des données, tandis que la clé publique est incluse dans le certificat et est utilisée par les autres parties pour vérifier les signatures.
Création de la demande de certificat : Le vendeur génère une demande de certificat (CSR - Certificate Signing Request) qui inclut des informations d'identification du vendeur ainsi que sa clé publique. Cette demande est signée avec la clé privée du vendeur pour prouver son origine.
Soumission de la demande à la CA : Le vendeur soumet la demande de certificat à la CA. Cela peut être fait en envoyant le CSR par e-mail, via un formulaire web ou à travers un autre canal sécurisé.
Émission du certificat par la CA : Une fois que la CA a vérifié et approuvé la demande, elle émet un certificat numérique pour le vendeur. Ce certificat inclut les informations d'identification du vendeur, sa clé publique et est signé numériquement par la CA.
Installation du certificat par le vendeur : Le vendeur installe le certificat sur son système ou son serveur. Cela lui permet d'utiliser sa clé privée correspondante pour signer numériquement des données et prouver son identité lors de communications ultérieures avec la CA, d'autres vendeurs ou des clients.


